======================================================================
Recipes for tasty things you can cook with your Coastermelt Shell (tm)
======================================================================


----
Time
----


ecc println(SysTime::now())

	This is a somewhat roundabout but convenient way to print the time.
	Same formatting used by the default %hook


%%hook -Rc 18ccc
println(SysTime::now())

	This installs a hook at the top of the ARM firmware's supervisor-mode main
	loop. As fast as it can without blocking the rest of the firmware, that
	hook will read the SoC's monotonic timer and write it to the console. The
	-R switch has it reset the system first, a good idea to start the
	experiment with a clean slate. And the -c command starts %console to watch
	for the output until you stop it with ctrl-C.


%%hook -Rc 18ccc
static u32 last = 0;
auto now = SysTime::now();
println(now.difference(last));
last = now;

	Hook the main loop, and print how many ticks has elapsed between
	successive main loop iterations. It's such a tight loop that the
	cost of the division in println_dec() makes a huge difference.


-----------
Concurrency
-----------


hook -Rscm "IRQ Vector" 40

	You can hook interrupt handlers too, but many of them live in SRAM. If the
	handler is in SRAM, normal hooking will fail and you'll need to use the
	-s (--sram) option. This sadly doesn't work for DRAM or any of the regions
	of memory above 8MB.


test_addr = 0x1ffb288
test_delay = 100
%%hook -Rc 18ccc
auto& test_word = *(vu32*) test_addr;
u32 sample_1 = test_word;
SysTime::wait_ms(test_delay);
u32 sample_2 = test_word;
if (sample_1 != sample_2) println(sample_1, sample_2);

    An experiment to test whether other code (interrupt, another CPU) is
    modifying a value while we're stuck in a busy-loop. The experiment begins
    a new sample pair once per main loop iteration. The address and delay can
    be set by changing shell variables.


test_addr = 0x1ffb288
test_delay = 100
%%hook -Rc 18ccc
auto& test_word = *(vu32*) test_addr;
u32 psr = begin_critical_section();
u32 sample_1 = test_word;
SysTime::wait_ms(test_delay);
u32 sample_2 = test_word;
if (sample_1 != sample_2) println(sample_1, sample_2);
end_critical_section(psr);

	Like above, but now we call the firmware's functions for disabling and
	enabling interrupts. If we still see changes here, we know the values are
	being modified by hardware and not an interrupt handler.


------------
Eject Button
------------


hook -Rrcm "Eject button" 18eb4

	This is a call site for the eject button handler in the ARM main loop,
	called as a result of checking button_release_debounce_state (1ffb288).
	With -r (replace) mode, this inhibits the usual button press behaviors and
	lets you hook your own code up to the button, running a friendly main loop
	context.


---------
Main Loop
---------

hook -Rcm "Top of main loop" 18ccc

    The ARM application main loop, at the top of every iteration. Put anything
    you want to poll here and it will run in a very tight loop but without
    stalling communications.


---------------------------
Unknown Hardware Device #xx
---------------------------
- ISR vector 0x14
- Continuously active while polling the backdoor


hook -Rc 213f6

	First decision byte in ISR loaded into r0. From this trace, it looks like
	r0 is always 3, but I'd like to be sure:


%%hook -Rc 213f6
if (r0 != 3) default_hook(regs)

	This conditionally invokes the default hook handler (the one used for the
	one-line version of hook) only if we see something surprising. This is a
	really useful pattern for filtering streams of noisy information, and it
	runs at the speed of the hook mechanism in native code, not limited by the
	slow debug backdoor.

	This is silent at first, suggesting that the output is indeed always 3.
	You need two things to help you trust a negative experamental result like
	this one:

    - It must not have crashed. This is why the console has the little "-\|/"
      spinner animation when it's idle. It's actually polling the console
      buffer as fast as possible, and the spinner is a condensed version of
      that activity.

    - It helps to have something trivially similar that gave us a positive
      result. In this case, that was the same hook at the same address without
      the conditional.

    Eject generated nothing new, but on putting the tray back in there was a
    flood of juicy r0=0 messages with data streaming by on the stack.

    I suspect there's some kind of big heavy re-initialization that happens
    when the tray is opened or (especially) when it's closed. This always seems to
    cause recoverable errors in talking to the backdoor.

    The binary blobs flowing by reminded me of the large possibly-DSP firmware
    blobs I've seen in the firmware image... tried searching a few middle-
    looking strings in the firmare image, nothing.



