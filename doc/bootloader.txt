=================
MT1939 Bootloader
=================


Notation
--------

All numbers are hexadecimal.

Memory accesses are denoted as Width[Address], where Width is B, H, or (blank)
for Byte, Halfword, or Word respectively.

C-style operators "|=", "&=", etc. are shorthand for read-modify-write
operations which require a load and store.


Memory Map
----------

00000000 - 00000fff      Encrypted page?
                         May be transparently decrypted on exec?
                         - ARM code issues function calls into this page
                         - Looks like part of a syscall interface

00001000 - 000013ff      ARM startup code
                         - Low level bootloader
                
00001400 - 00002fff      ARM application code
                         - Includes main loop, SCSI command handlers
                         - Might be usermode
                         - Probably compiled using a higher level SDK

00003000 - 0000dfff      ARM library code
                         - Bulk of code is here
                         - Invoked by startup code

0000e000 - 0000ffff      8051 firmware image
                         - Self contained, maps to 8051 code memory
                         - Unknown how this is loaded
                         - Implements USB Storage protocol
                         - Interprocessor communication pipe between ARM and 8051

00010000 - 001e1fff      Loadable firmware image (1863 kB)

001e2000 - 001fffff      Bootloader information region (120 kB)
                         - Not checksummed
                         - Lots of reserved blank space
                         - Interesting data table at 1f2000
                         - Might be keys at 1f2080
                         - Zero-padded 256-byte blob at 1fe000
                              Opcodes or other structured data,
                              some aligned 16-bit values too
                         - Signature block at 1ff000, matches 16 bytes at 10ff0
                         - Infonub at 1fffd0 (product/vendor/version, weak checksum)


Initialization
--------------

First known step:

- ARM processor starts, PC=1000 T=0
  Running first bootloader section (1000-13ff) 
  
  - SoC main reset?
    
    [4001000] |= 10
    [4001000] &= 10

  - Set up RAM segments?
    First one is 6 kB, second one is 2 MB.

    nop nop
    [4020f20] = 02000000
    nop nop
    [4020f24] = 020019ff
    nop nop

    This register address calculated based on ram address; could be protection info?

    [4020f04] |= 0x800

    This seems related to the RAM segment, but it's reading values from the
    encrypted page! And they're unaligned addresses! It's probably safe to say
    the hardware does something special with these addresses.

    [4030f04] = [2]
    [4031004] = [8]
    [4031000] = 40000800

    Addresses calculated based on masking off 1ffff/2

    [40300f4] = 1ffff
    [4030f20] = 1e00000
    [4030f24] = 1ffffff

    [4030f40] = 2000000
    [4030f44] = 20019ff

    [4030f04] = 8802

  - Something else!

    [4011f04] |= 0xB00

  - Stack to 2000d80
  - CPSR to D3
  - Branch to next bootloader section, "MT1939 Boot Code" at 3010.

- Boot code 3010

   ...


Magic numbers
-------------

a1b9d358 13201959



Signature
---------

Bootloader reads two 16-byte regions:

 01ff000: d7a3 e98e 5a3a 2573 357d 324b 0ccb 1f53  ....Z:%s5}2K...S
 0010ff0: d7a3 e98e 5a3a 2573 357d 324b 0ccb 1f53  ....Z:%s5}2K...S

From near the beginning and end of the application firmware image.
All 16-byte signatures were identical in the images seen so far.

It looks like they're intended to be identical, but I haven't yet
determined exactly how they're checked. Seems like it involves the
8051 processor as well.

The one at 1ff000 is read just after the infonub checksum is validated.


 xxxxxxxx - 001e2000    blocksize 1000
  


Infonub
-------

There's a 48-byte region at the end of flash (001fffd0 - 001fffff) that I've
been calling the "infonub". It's a tiny nub of versioning and integrity data
that the bootloader checks before invoking the application firmware.

1fff90: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................
1fffa0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................
1fffb0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................
1fffc0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................
1fffd0: 54 53 53 54 63 6f 72 70 42 44 44 56 44 57 20 53 TSSTcorpBDDVDW S
1fffe0: 45 2d 35 30 36 43 42 20 54 53 30 31 3e 22 04 00 E-506CB TS01>"..
1ffff0: 54 53 20 ff ff ff ff ff aa aa ff ff ff ff 59 18 TS ...........Y.

Most of this is clear vendor, product, and revision info.
A lot of it is boring.

The last two bytes are a really dumb 16-bit checksum:

def get_stored_checksum(fw):
    return (ord(fw[0x1ffffe]) << 8) | ord(fw[0x1fffff])

def calculate_checksum(fw):
    s = 0
    for i in range(0x10000, 0x1e2000):
        s = 0xffff & (s + ord(fw[i]))
    return s

def file_info(name):
    fw = open(name, 'rb').read()
    print '%s stored:%04x calc:%04x' % (
        name, get_stored_checksum(fw), calculate_checksum(fw))

>>> file_info('SE-506CB_TS00.bin')
SE-506CB_TS00.bin stored:06e8 calc:06e8

>>> file_info('SE-506CB_TS01.bin')
SE-506CB_TS01.bin stored:5918 calc:5918

*** Verified that this is not the ONLY checksum in use. A trivially hacked
    firmware will not boot even with this checksum fixed.


Shared Block
------------

Not sure if this is just an internal command passing mechanism or if it's
intended for use by app firmware, but there are sure some juicy bits here.

2000d80 - 2000e0b    
  Seems to be shared by the 8051 and ARM processors.

word [ 0]
word [ 4]
   b [ 8]
   b [ 9]
   b [ a]  Transfer length
   b [ b]
word [ c]
word [10]  Address (ARM)
            1e2000
         >= 200000   Causes exit from bootloader into firmware
    
word [14]  Residual byte count
          <  10000   Different bootloader paths
    
word [18]  Address (8051)
             Stored (low 24 bits) in [4032010]

word [1c]  Total byte count

word [20]  ARM address of mapped 8051 memory
           Aligned on a 16MB boundary (low 24 bits are zero?)

             +0000   Might be RAM? Related to signature checking?
             +1000   Start of firmware RAM
     
           Calculated based on address from [4030f5c], but the specifics may
           depend on hardware version.

word [24]  Index inside the 8051 mapped area (inquiry data?)
word [28]  SCSI command response
word [2c]
word [30]

Another shared block, used much less. Been calling this "zr" (zero reference)
since I saw a reference associated with a zero'ed (bss) segment in the 8051
MCU setup. Whereas the regular shared block is referenced to 0xE010 in the
8051 image, zr is referenced to 0xE09C. It's right after the other shared block:

2000e0c - 2000ee7

   b [31]  Checked early on in INQUIRY?
   b [3d]
   b [5c]  SCSI command data block, starting with opcode byte


~MeS`14
