=================
MT1939 Bootloader
=================


Notation
--------

All numbers are hexadecimal.

Memory accesses are denoted as Width[Address], where Width is B, H, or (blank)
for Byte, Halfword, or Word respectively.

C-style operators "|=", "&=", etc. are shorthand for read-modify-write
operations which require a load and store.


Memory Map
----------

00000000 - 00000fff      Encrypted page?
                         May be transparently decrypted on exec?
                         - ARM code issues function calls into this page
                         - Looks like part of a syscall interface

00001000 - 000013ff      ARM startup code
                         - Low level bootloader
                
00001400 - 00002fff      ARM application code
                         - Includes main loop, SCSI command handlers
                         - Might be usermode
                         - Probably compiled using a higher level SDK

00003000 - 0000dfff      ARM library code
                         - Bulk of code is here
                         - Invoked by startup code

0000e000 - 0000ffff      8051 firmware image
                         - Self contained, maps to 8051 code memory
                         - Unknown how this is loaded
                         - Implements USB Storage protocol
                         - Interprocessor communication pipe between ARM and 8051

Initialization
--------------

First known step:

- ARM processor starts, PC=1000 T=0
  Running first bootloader section (1000-13ff) 
  
  - SoC main reset?
    
    [4001000] |= 10
    [4001000] &= 10

  - Set up RAM segments?
    First one is 6 kB, second one is 2 MB.

    nop nop
    [4020f20] = 02000000
    nop nop
    [4020f24] = 020019ff
    nop nop

    This register address calculated based on ram address; could be protection info?

    [4020f04] |= 0x800

    This seems related to the RAM segment, but it's reading values from the
    encrypted page! And they're unaligned addresses! It's probably safe to say
    the hardware does something special with these addresses.

    [4030f04] = [2]
    [4031004] = [8]
    [4031000] = 40000800

    Addresses calculated based on masking off 1ffff/2

    [40300f4] = 1ffff
    [4030f20] = 1e00000
    [4030f24] = 1ffffff

    [4030f40] = 2000000
    [4030f44] = 20019ff

    [4030f04] = 8802

  - Something else!

    [4011f04] |= 0xB00

  - Stack to 2000d80
  - CPSR to D3
  - Branch to next bootloader section, "MT1939 Boot Code" at 3010.

- Boot code 3010

   ...

   Theory: Looks like the ARM portion starts first, but it always boots up
           the 8051 portion and puts it in control. It copies over relevant
           portions of the application firmware, then the 8051 decides whether
           to boot.


Magic numbers
-------------

a1b9d358 13201959



Validation
----------

Bootloader reads two 16-byte regions:

 01ff000: d7a3 e98e 5a3a 2573 357d 324b 0ccb 1f53  ....Z:%s5}2K...S
 0010ff0: d7a3 e98e 5a3a 2573 357d 324b 0ccb 1f53  ....Z:%s5}2K...S

From near the beginning and end of the application firmware image.
All 16-byte signatures were identical in the images seen so far.

It looks like they're intended to be identical, but I haven't yet
determined exactly how they're checked. Seems like it involves the
8051 processor as well.


Infonub
-------

There's a 48-byte region at the end of flash (001fffd0 - 001fffff) that I've
been calling the "infonub". It's a tiny nub of versioning and integrity data that the bootloader checks before invoking the application firmware.

  * Also the smaller region at 1ff000.


~MeS`14
