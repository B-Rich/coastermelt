=================
MT1939 Bootloader
=================


Notation
--------

All numbers are hexadecimal.

Memory accesses are denoted as Width[Address], where Width is B, H, or (blank)
for Byte, Halfword, or Word respectively.

C-style operators "|=", "&=", etc. are shorthand for read-modify-write
operations which require a load and store.


Memory Map
----------

00000000 - 00000fff      Encrypted page?
                         May be transparently decrypted on exec?
                         - ARM code issues function calls into this page
                         - Looks like part of a syscall interface

00001000 - 000013ff      ARM startup code
                         - Low level bootloader
                
00001400 - 00002fff      ARM application code
                         - Includes main loop, SCSI command handlers
                         - Might be usermode
                         - Probably compiled using a higher level SDK

00003000 - 0000dfff      ARM library code
                         - Bulk of code is here
                         - Invoked by startup code

0000e000 - 0000ffff      8051 firmware image
                         - Self contained, maps to 8051 code memory
                         - Unknown how this is loaded
                         - Implements USB Storage protocol
                         - Interprocessor communication pipe between ARM and 8051

00010000 - 001e1fff      Loadable firmware image (1863 kB)

001e2000 - 001fffff      Bootloader information region (120 kB)
                         - Not checksummed
                         - Lots of reserved blank space
                         - Interesting data table at 1f2000
                         - Might be keys at 1f2080
                         - Zero-padded 256-byte blob at 1fe000
                              Opcodes or other structured data,
                              some aligned 16-bit values too
                         - Signature block at 1ff000, matches 16 bytes at 10ff0
                         - Infonub at 1fffd0 (product/vendor/version, weak checksum)


Initialization
--------------

First known step:

- ARM processor starts, PC=1000 T=0
  Running first bootloader section (1000-13ff) 
  
  - SoC main reset?
    
    [4001000] |= 10
    [4001000] &= 10

  - Set up RAM segments?
    First one is 6 kB, second one is 2 MB.

    nop nop
    [4020f20] = 02000000
    nop nop
    [4020f24] = 020019ff
    nop nop

    This register address calculated based on ram address; could be protection info?

    [4020f04] |= 0x800

    This seems related to the RAM segment, but it's reading values from the
    encrypted page! And they're unaligned addresses! It's probably safe to say
    the hardware does something special with these addresses.

    [4030f04] = [2]
    [4031004] = [8]
    [4031000] = 40000800

    Addresses calculated based on masking off 1ffff/2

    [40300f4] = 1ffff
    [4030f20] = 1e00000
    [4030f24] = 1ffffff

    [4030f40] = 2000000
    [4030f44] = 20019ff

    [4030f04] = 8802

  - Something else!

    [4011f04] |= 0xB00

  - Stack to 2000d80
  - CPSR to D3
  - Branch to next bootloader section, "MT1939 Boot Code" at 3010.

- Boot code 3010

   ...

  SVC 0x123456, R0=18 R1=20026
    R1 could plausibly be an entry-related address

  (Sadly this SVC leads into the encrypted area...)


- Hard to nail down exactly which checks go into running or not running the image,
  since it's a huge foresty state machine. Here's a running list of things that
  seem to matter:

  - Signature at 1ff000 matches 10ff0
  - Checksum at 1ffffe matches, over range 10000-1e0000


App-select Register
-------------------

The word register at [4002058] seems to be heavily involved in the process of
deciding what path the bootloader takes; whether to rn the app, and a few
other things. So I called it "appselect".

Just prior to the main loop:

  [4002058] |= 40
  (Set bit 6)

In the main loop:

  If bit6 is 0, act as if the checksum test failed.

  If bit6 is 1, enable an increment by 1f000 and transfer of 1000 bytes on the
  way out (setting ref[10] to 200000).

Just prior to exit (after ref[10] >= 200000)

  [4002058] |= 80
  (Set bit 7)


Magic numbers
-------------

a1b9d358 13201959



Signature
---------

Bootloader reads two 16-byte regions:

 01ff000: d7a3 e98e 5a3a 2573 357d 324b 0ccb 1f53  ....Z:%s5}2K...S
 0010ff0: d7a3 e98e 5a3a 2573 357d 324b 0ccb 1f53  ....Z:%s5}2K...S

From near the beginning and end of the application firmware image.
All 16-byte signatures were identical in the images seen so far.

It looks like they're intended to be identical, but I haven't yet
determined exactly how they're checked. Seems like it involves the
8051 processor as well.

The one at 1ff000 is read just after the infonub checksum is validated.


 xxxxxxxx - 001e2000    blocksize 1000
  


Infonub
-------

There's a 48-byte region at the end of flash (001fffd0 - 001fffff) that I've
been calling the "infonub". It's a tiny nub of versioning and integrity data
that the bootloader checks before invoking the application firmware.

1fff90: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................
1fffa0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................
1fffb0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................
1fffc0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................
1fffd0: 54 53 53 54 63 6f 72 70 42 44 44 56 44 57 20 53 TSSTcorpBDDVDW S
1fffe0: 45 2d 35 30 36 43 42 20 54 53 30 31 3e 22 04 00 E-506CB TS01>"..
1ffff0: 54 53 20 ff ff ff ff ff aa aa ff ff ff ff 59 18 TS ...........Y.

Most of this is clear vendor, product, and revision info.
A lot of it is boring.

The last two bytes are a really dumb 16-bit checksum:

def get_stored_checksum(fw):
    return (ord(fw[0x1ffffe]) << 8) | ord(fw[0x1fffff])

def calculate_checksum(fw):
    s = 0
    for i in range(0x10000, 0x1e2000):
        s = 0xffff & (s + ord(fw[i]))
    return s

def file_info(name):
    fw = open(name, 'rb').read()
    print '%s stored:%04x calc:%04x' % (
        name, get_stored_checksum(fw), calculate_checksum(fw))

>>> file_info('SE-506CB_TS00.bin')
SE-506CB_TS00.bin stored:06e8 calc:06e8

>>> file_info('SE-506CB_TS01.bin')
SE-506CB_TS01.bin stored:5918 calc:5918

*** Verified that this is not the ONLY checksum in use. A trivially hacked
    firmware will not boot even with this checksum fixed.


Image Validity
--------------

How does the bootloader decide that an application firmware image (everything
from 10000 to 1fffff) is valid before executing it? If this validity check
fails, the bootloader will present its own tiny USB storage interface that
only supports firmware uploading.

- The bootloader region from 0 through 10000 is explicitly NOT verified. It
  seems to be completely ignored during upload. Possibly it was included in
  the flashing procedure to support initial installation of the loader in th
  factory using the same binary image?

- There's a 16-bit checksum at 1ffffe, covering memory from 10000 up to
  1e2000. This is necessary but not sufficieny for the firmware to boot.

- Experimentally found an area that isn't validated

  1e2000 - 1f2000  (64 kB).  This might be reserved for runtime storage,
                             hence the nice round size and lack of checksum.
                             It contains all FF in the shipping firmware images.

  1f2000 - 1fa07f  (0x8080)  The beginning contains an important-looking table
                             that I don't want to change until I know what I'm
                             doing, but the end of this region is zero-padded.
                             Changes here still allow the image to boot.

  1fa080 -                   Changes here also seem fine. This whole region that
                             isn't CRC-protected might not be validated, but lots
                             of it is scary data tables that will probably brick
                             the device if it does boot the modified image.


* Test mod at 1baee, *is* caught by checksum.
  Can't make the image boot at this point solely by fixing the checksum.
  Looking for other copies of the sum, none found yet.
  
  Candidates for other checksums:

     10424
     


~MeS`14
